<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ValidaÃ§Ã£o Final - Sistema Centralizado</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        .test-container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
            border-radius: 0 8px 8px 0;
        }
        .test-result {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border-left-color: #dc3545;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border-left-color: #17a2b8;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            border-left-color: #ffc107;
        }
        button {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }
        .btn-success { background: linear-gradient(45deg, #28a745, #20c997); }
        .btn-danger { background: linear-gradient(45deg, #dc3545, #e83e8c); }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            border: 1px solid #dee2e6;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .online { background-color: #28a745; color: white; }
        .offline { background-color: #dc3545; color: white; }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="header">
            <h1>ğŸ§ª ValidaÃ§Ã£o Final do Sistema Centralizado</h1>
            <p>VerificaÃ§Ã£o completa do sistema de bloqueio baseado exclusivamente no Supabase</p>
        </div>

        <div class="test-section">
            <h3>ğŸ”§ Controles de Teste</h3>
            <button onclick="runFullValidation()" class="btn-success">ğŸš€ Executar ValidaÃ§Ã£o Completa</button>
            <button onclick="testConnectionOnly()">ğŸ”Œ Testar Apenas ConexÃ£o</button>
            <button onclick="testBlockingLogic()">ğŸ”’ Testar LÃ³gica de Bloqueio</button>
            <button onclick="clearResults()" class="btn-danger">ğŸ§¹ Limpar Resultados</button>
        </div>

        <div id="progress-section" style="display: none;">
            <h4>ğŸ“Š Progresso dos Testes</h4>
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill"></div>
            </div>
            <p id="progress-text">Preparando testes...</p>
        </div>

        <div id="results"></div>

        <div class="test-section">
            <h3>ğŸ“‹ Checklist de ValidaÃ§Ã£o</h3>
            <ul id="validation-checklist">
                <li>ğŸ”Œ Conectividade com Supabase</li>
                <li>ğŸ“Š FunÃ§Ã£o getCompletedSubmissions retorna apenas dados Supabase</li>
                <li>ğŸ”’ FunÃ§Ã£o getCompletedStudentIds gera Set corretamente</li>
                <li>âš ï¸ Sistema ignora dados locais para bloqueio</li>
                <li>ğŸ“ Logs de debug funcionando</li>
                <li>ğŸ¯ Mensagens de "fonte Ãºnica" aparecem</li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { dataService } from './src/services/dataService.js';
        import { logService } from './src/services/logService.js';

        // FunÃ§Ã£o de bloqueio centralizado (cÃ³pia da implementaÃ§Ã£o real)
        async function getCompletedStudentIds(classId) {
            try {
                console.log('ğŸ” Buscando estudantes completados APENAS no Supabase (fonte Ãºnica de verdade)');

                // Busca submissÃµes completadas (agora sÃ³ retorna dados do Supabase)
                const completedSubmissions = await dataService.getCompletedSubmissions(classId);

                // Retorna Set com IDs Ãºnicos dos estudantes
                const completedIds = new Set(completedSubmissions.map(submission => submission.studentId));

                // Debug: Mostra IDs bloqueados
                console.log(`ğŸ”’ Sistema centralizado: ${completedIds.size} estudantes bloqueados`);
                console.log('ğŸ“‹ IDs bloqueados:', Array.from(completedIds));

                return completedIds;

            } catch (error) {
                console.warn('Erro ao buscar estudantes completados:', error);
                return new Set();
            }
        }

        // Torna as funÃ§Ãµes globais
        window.runFullValidation = runFullValidation;
        window.testConnectionOnly = testConnectionOnly;
        window.testBlockingLogic = testBlockingLogic;
        window.clearResults = clearResults;

        let testProgress = 0;
        const totalTests = 6;

        function updateProgress(current, message) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const progressSection = document.getElementById('progress-section');

            progressSection.style.display = 'block';
            const percentage = (current / totalTests) * 100;
            progressFill.style.width = percentage + '%';
            progressText.textContent = message;
        }

        function addResult(message, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = message;
            results.appendChild(div);

            // Auto-scroll para o resultado mais recente
            div.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('progress-section').style.display = 'none';
            testProgress = 0;
        }

        async function runFullValidation() {
            clearResults();
            addResult('ğŸš€ <strong>Iniciando ValidaÃ§Ã£o Completa do Sistema Centralizado</strong>', 'info');

            try {
                // Teste 1: Conectividade
                updateProgress(1, 'Testando conectividade com Supabase...');
                await testConnectionOnly();

                // Teste 2: Fonte de dados
                updateProgress(2, 'Verificando fonte de dados...');
                await validateDataSource();

                // Teste 3: LÃ³gica de bloqueio
                updateProgress(3, 'Testando lÃ³gica de bloqueio...');
                await testBlockingLogic();

                // Teste 4: Logs do sistema
                updateProgress(4, 'Verificando logs do sistema...');
                await validateSystemLogs();

                // Teste 5: Integridade dos dados
                updateProgress(5, 'Verificando integridade dos dados...');
                await validateDataIntegrity();

                // Teste 6: CenÃ¡rios de falha
                updateProgress(6, 'Testando cenÃ¡rios de falha...');
                await testFailureScenarios();

                updateProgress(6, 'ValidaÃ§Ã£o completa finalizada!');
                addResult('ğŸ‰ <strong>ValidaÃ§Ã£o Completa Finalizada!</strong>', 'success');

            } catch (error) {
                addResult(`âŒ <strong>Erro durante validaÃ§Ã£o:</strong> ${error.message}`, 'error');
            }
        }

        async function testConnectionOnly() {
            addResult('ğŸ”Œ <strong>Teste 1: Conectividade</strong>', 'info');

            try {
                const isOnline = await dataService.testConnection();
                if (isOnline) {
                    addResult(`âœ… ConexÃ£o com Supabase: <span class="status-badge online">ONLINE</span>`, 'success');
                } else {
                    addResult(`âš ï¸ ConexÃ£o com Supabase: <span class="status-badge offline">OFFLINE</span>`, 'warning');
                    addResult('âš ï¸ Sistema em modo offline - bloqueio centralizado nÃ£o funcionarÃ¡', 'warning');
                }

                const status = await dataService.getServiceStatus();
                addResult(`ğŸ“¡ ServiÃ§o ativo: ${status.activeService}`, 'info');

            } catch (error) {
                addResult(`âŒ Erro ao testar conexÃ£o: ${error.message}`, 'error');
            }
        }

        async function validateDataSource() {
            addResult('ğŸ“Š <strong>Teste 2: Fonte de Dados</strong>', 'info');

            try {
                const testClassId = '1';
                const submissions = await dataService.getCompletedSubmissions(testClassId);

                // Verificar se retorna apenas dados do Supabase
                const supabaseSubmissions = submissions.filter(s => s.source === 'supabase' || !s.isLocal);
                const localSubmissions = submissions.filter(s => s.isLocal);

                addResult(`ğŸ“Š Total de submissÃµes encontradas: ${submissions.length}`, 'info');
                addResult(`ğŸŒ SubmissÃµes do Supabase: ${supabaseSubmissions.length}`, 'info');
                addResult(`ğŸ’¾ SubmissÃµes locais: ${localSubmissions.length}`, 'info');

                if (localSubmissions.length === 0 || submissions.every(s => !s.isLocal)) {
                    addResult('âœ… Fonte de dados correta: Usando apenas Supabase', 'success');
                } else {
                    addResult('âš ï¸ AtenÃ§Ã£o: Sistema encontrou dados locais', 'warning');
                }

            } catch (error) {
                addResult(`âŒ Erro ao validar fonte de dados: ${error.message}`, 'error');
            }
        }

        async function testBlockingLogic() {
            addResult('ğŸ”’ <strong>Teste 3: LÃ³gica de Bloqueio</strong>', 'info');

            try {
                const testClassId = '1';
                const completedIds = await getCompletedStudentIds(testClassId);

                if (completedIds instanceof Set) {
                    addResult(`âœ… Retornou Set corretamente com ${completedIds.size} estudantes`, 'success');

                    if (completedIds.size > 0) {
                        addResult(`ğŸ“‹ IDs bloqueados: ${Array.from(completedIds).join(', ')}`, 'info');
                    } else {
                        addResult('â„¹ï¸ Nenhum estudante bloqueado no momento', 'info');
                    }
                } else {
                    addResult('âŒ Erro: NÃ£o retornou um Set', 'error');
                }

                // Testar alguns IDs especÃ­ficos
                const testIds = [1, 2, 3, 999];
                for (const id of testIds) {
                    const isBlocked = completedIds.has(id);
                    const status = isBlocked ? 'ğŸ”’ BLOQUEADO' : 'âœ… LIBERADO';
                    const type = isBlocked ? 'warning' : 'success';
                    addResult(`Estudante ID ${id}: ${status}`, type);
                }

            } catch (error) {
                addResult(`âŒ Erro ao testar lÃ³gica de bloqueio: ${error.message}`, 'error');
            }
        }

        async function validateSystemLogs() {
            addResult('ğŸ“ <strong>Teste 4: Logs do Sistema</strong>', 'info');

            // Capturar logs do console
            const originalLog = console.log;
            const originalWarn = console.warn;
            const logs = [];

            console.log = (...args) => {
                logs.push({ type: 'log', message: args.join(' ') });
                originalLog(...args);
            };

            console.warn = (...args) => {
                logs.push({ type: 'warn', message: args.join(' ') });
                originalWarn(...args);
            };

            try {
                // Executar funÃ§Ã£o que gera logs
                await getCompletedStudentIds('1');

                // Verificar se logs esperados estÃ£o presentes
                const centralizedLogs = logs.filter(log =>
                    log.message.includes('fonte Ãºnica') ||
                    log.message.includes('Sistema centralizado') ||
                    log.message.includes('SISTEMA CENTRALIZADO')
                );

                if (centralizedLogs.length > 0) {
                    addResult('âœ… Logs do sistema centralizado funcionando', 'success');
                    centralizedLogs.forEach(log => {
                        addResult(`ğŸ“ Log: ${log.message}`, 'info');
                    });
                } else {
                    addResult('âš ï¸ Logs do sistema centralizado nÃ£o encontrados', 'warning');
                }

            } finally {
                // Restaurar console original
                console.log = originalLog;
                console.warn = originalWarn;
            }
        }

        async function validateDataIntegrity() {
            addResult('ğŸ” <strong>Teste 5: Integridade dos Dados</strong>', 'info');

            try {
                const testClassId = '1';

                // Buscar dados duas vezes para verificar consistÃªncia
                const firstCall = await getCompletedStudentIds(testClassId);
                const secondCall = await getCompletedStudentIds(testClassId);

                const firstArray = Array.from(firstCall).sort();
                const secondArray = Array.from(secondCall).sort();

                if (JSON.stringify(firstArray) === JSON.stringify(secondArray)) {
                    addResult('âœ… Dados consistentes entre chamadas', 'success');
                } else {
                    addResult('âš ï¸ InconsistÃªncia detectada entre chamadas', 'warning');
                }

                // Verificar se IDs sÃ£o vÃ¡lidos
                const invalidIds = firstArray.filter(id => !Number.isInteger(id) || id <= 0);
                if (invalidIds.length === 0) {
                    addResult('âœ… Todos os IDs sÃ£o vÃ¡lidos', 'success');
                } else {
                    addResult(`âŒ IDs invÃ¡lidos encontrados: ${invalidIds.join(', ')}`, 'error');
                }

            } catch (error) {
                addResult(`âŒ Erro ao validar integridade: ${error.message}`, 'error');
            }
        }

        async function testFailureScenarios() {
            addResult('ğŸš¨ <strong>Teste 6: CenÃ¡rios de Falha</strong>', 'info');

            try {
                // Teste com classe inexistente
                const emptyResult = await getCompletedStudentIds('999999');
                if (emptyResult instanceof Set && emptyResult.size === 0) {
                    addResult('âœ… Classe inexistente retorna Set vazio', 'success');
                } else {
                    addResult('âš ï¸ Comportamento inesperado para classe inexistente', 'warning');
                }

                // Teste com parÃ¢metro invÃ¡lido
                const invalidResult = await getCompletedStudentIds(null);
                if (invalidResult instanceof Set) {
                    addResult('âœ… ParÃ¢metro invÃ¡lido tratado corretamente', 'success');
                } else {
                    addResult('âŒ ParÃ¢metro invÃ¡lido nÃ£o tratado', 'error');
                }

            } catch (error) {
                addResult(`âŒ Erro durante teste de falhas: ${error.message}`, 'error');
            }
        }

        // Auto-executar teste de conectividade ao carregar
        setTimeout(() => {
            addResult('ğŸ¯ <strong>Sistema de ValidaÃ§Ã£o Carregado</strong>', 'info');
            addResult('ğŸ“‹ Use os botÃµes acima para executar testes especÃ­ficos ou validaÃ§Ã£o completa', 'info');
        }, 1000);
    </script>
</body>
</html>